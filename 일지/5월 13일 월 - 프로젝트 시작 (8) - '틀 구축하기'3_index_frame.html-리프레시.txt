5월 13일 월 → ※ ▶ ◈ ∴ 🫡

-----------------------------------------------------------------
이 코드에서는 AJAX (Asynchronous JavaScript and XML)를 사용하여 서버에서 데이터를 비동기적으로 가져오고 있습니다. AJAX는 JavaScript를 사용하여 웹 페이지가 새로 고쳐지지 않고도 서버와 통신할 수 있게 해주는 기술입니다. 이 코드에서는 XML HttpRequest 객체를 사용하여 데이터를 가져오고 있습니다.

∴ 비동기적으로 서버에서 데이터를 가져온다???
- 


이 HTML 코드는 'index_frame.html' 템플릿으로 사용될 것으로 보입니다. 
이 템플릿은 로그 데이터를 표시하는 테이블을 포함하고 있으며, 이 테이블은 AJAX를 사용하여 주기적으로 업데이트됩니다.

여기서 중요한 부분은 JavaScript 섹션입니다. 이 섹션에서는 'updateLogs()' 함수가 정의되어 있으며, 이 함수는 AJAX를 사용하여 '/get_logs' 엔드포인트에서 데이터를 가져와서 테이블의 내용을 업데이트합니다. 'setInterval()' 함수를 사용하여 이 함수가 일정 시간마다 호출되도록 설정되어 있습니다.

따라서 이 템플릿은 사용자에게 'index_frame' 페이지에서 주기적으로 로그 데이터를 업데이트하는 인터페이스를 제공할 것입니다. 이를 위해서는 '/get_logs' 엔드포인트가 정확하게 구현되어 있어야 하며, 해당 엔드포인트가 로그 데이터를 올바르게 반환해야 합니다.

→ 그런데 적용이 안되네... ;; XXXXXXXXXXXX


----

logs 페이지 자체는 browser 창에서 업데이트가 되진 않습니다. 새로고침을 했을 때만 업데이트가 적용되는데 테이블에 추가 및 제거 했을 때, 아약스를 통해 5초마다 'updateLogs()' 함수를 호출하여 서버에서 로그 데이터를 가져와서 테이블에 업데이트하는 방식으로 페이지에서 실시간으로 표시되게끔 할 수는 없을까요?

>>새로운 데이터를 추가하거나 제거하는 경우, 
 서버에서 새로운 데이터를 가져와서 전체 테이블을 다시 그리는 것이 아닌, 변경된 부분만 업데이트하는 방식을 채택해야 합니다. 이를 위해서는 서버에서 전송된 데이터에 변경된 부분만을 포함시키고, 클라이언트 측에서는 이 변경된 데이터만을 이용하여 테이블을 갱신해야 합니다.

서버 측에서는 변경된 로그 데이터를 제공할 수 있는 엔드포인트를 구현하고, 클라이언트 측에서는 이 엔드포인트를 호출하여 변경된 데이터를 가져와서 테이블을 업데이트해야 합니다.

예를 들어, 클라이언트 측에서는 이전에 받은 데이터와 새로 받은 데이터를 비교하여 추가된 로그는 테이블에 추가하고, 삭제된 로그는 테이블에서 제거하는 방식으로 실시간으로 페이지를 업데이트할 수 있습니다.

이러한 방식으로 구현하면, 새로운 데이터가 추가되거나 삭제될 때에도 페이지를 새로고침하지 않고도 변경된 내용을 실시간으로 표시할 수 있습니다.

>> index_frame.html

이 작업을 수행할 수 있는 자바스크립트 코드를 index_frame.html 파일에 구현해야 합니다.

index_frame.html 파일은 클라이언트 측에서 실행되므로, 새로운 데이터를 가져와서 테이블을 업데이트하는 기능을 여기에서 구현하는 것이 적절합니다. 클라이언트 측에서는 AJAX를 사용하여 서버에서 데이터를 주기적으로 가져와야 하고, 이전 데이터와 비교하여 변경 사항을 식별하고 테이블을 업데이트해야 합니다.

따라서 index_frame.html 파일에 실시간 업데이트를 위한 JavaScript 코드를 구현하고, 서버로부터 새로운 데이터를 가져오는 데 필요한 AJAX 요청도 해당 파일에서 처리해야 합니다.

1. updateLogs() 함수는 AJAX를 사용하여 서버로부터 로그 데이터를 가져오고, 가져온 데이터를 사용하여 테이블을 업데이트합니다.
2. 페이지가 로드될 때와 5초마다 updateLogs() 함수가 호출되어 테이블이 실시간으로 업데이트됩니다.
3.'/get_logs' 엔드포인트를 통해 서버에서 데이터를 가져오는 AJAX 요청이 이루어집니다. 이 엔드포인트는 서버 측에서 로그 데이터를 반환하는 역할을 담당합니다.


---- 2교시
기존에 연결되어있는 데이터베이스에 저장되어있는 데이터들은 그대로 출력하고
새로 추가되거나 제거되는 경우에 업데이트 되도록 하고 싶습니다.

1.클라이언트가 처음 로드될 때, 서버에서 모든 로그 데이터를 가져와 테이블에 표시합니다.
2.주기적으로 서버로부터 새로운 데이터를 가져옵니다.
3.이전에 표시된 데이터와 새로 가져온 데이터를 비교하여 변경된 부분을 식별합니다.
4.변경된 부분을 테이블에 반영하여 업데이트합니다.
아래는 위의 단계에 따라 클라이언트 측에서 변경된 부분만을 업데이트하는 JavaScript 코드의 예시
...
이 코드는 서버로부터 가져온 로그 데이터와 이전에 가져온 로그 데이터를 비교하여 변경된 부분을 식별하고, 추가된 부분은 테이블에 추가하고 삭제된 부분은 테이블에서 제거하는 방식으로 동작합니다.

---- 3교시

Server-Sent Events를 사용하지 않고도 실시간으로 데이터베이스에서 가져온 로그 정보를 업데이트하는 방법이 있습니다. 이를 위해 JavaScript를 사용하여 일정 간격으로 페이지를 업데이트할 수 있습니다. 이 방법은 Ajax를 사용하여 주기적으로 데이터베이스에서 새로운 데이터를 가져와서 페이지를 업데이트합니다.

아래는 index_frame.html 파일에 추가하여 데이터베이스에서 로그 정보를 주기적으로 업데이트하는 JavaScript 코드
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Index Frame Content</title>
</head>
<body>
    <h1>LOGS Page</h1>
    <table id="log-table">
        <thead>
            <tr>
                <th>Date</th>
                <th>Occurrence Time</th>
                <th>Incident</th>
            </tr>
        </thead>
        <tbody id="log-table-body">
            <!-- Logs will be dynamically added here -->
            {% for log in logs %}
            <tr>
                <td>{{ log.date }}</td>
                <td>{{ log.occurrence_time }}</td>
                <td>{{ log.incident }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

    <script>
        // 페이지 업데이트 함수
        function updateLogs() {
            // AJAX를 사용하여 서버에서 데이터 가져오기
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function() {
                if (xhr.readyState === XMLHttpRequest.DONE) {
                    if (xhr.status === 200) {
                        // 응답 받은 데이터를 테이블에 추가
                        var logTableBody = document.getElementById('log-table-body');
                        logTableBody.innerHTML = xhr.responseText;
                    } else {
                        console.error('서버로부터 데이터를 가져오지 못했습니다.');
                    }
                }
            };
            xhr.open('GET', '/get_logs', true); // 데이터를 가져올 엔드포인트 설정
            xhr.send();
        }

        // 일정 시간마다 페이지 업데이트 설정 (예: 5초마다)
        setInterval(updateLogs, 5000); // 5000 밀리초 = 5초
    </script>
</body>
</html>
위 코드는 5초마다 /get_logs 엔드포인트로부터 로그 데이터를 가져와서 테이블을 업데이트하는 JavaScript 코드입니다. 이 코드를 사용하면 페이지를 새로 고치지 않고도 주기적으로 로그 정보를 업데이트할 수 있습니다.

서버 측에서는 '/get_logs' 엔드포인트를 구현하여 클라이언트에게 실시간으로 로그 데이터를 제공해야 합니다. 이 엔드포인트는 데이터베이스에서 로그 정보를 가져오는 역할을 합니다.

---- 4교시

만일 get_logs 엔드포인트가 이미 로그 데이터를 가져오는 데 사용된다면, 추가적인 add_log 함수를 정의할 필요는 없습니다. get_logs 엔드포인트가 새로운 로그를 가져오는 데 사용될 수 있습니다.


네, 맞습니다. 만일 이미 get_logs 엔드포인트가 로그 데이터를 가져오는 데 사용된다면, 추가적인 add_log 함수를 정의할 필요는 없습니다. 대신에 get_logs 엔드포인트를 수정하여 새로운 로그를 추가하는 기능을 통합할 수 있습니다.

여기에는 /add_log 엔드포인트를 별도로 정의하는 대신, get_logs 엔드포인트에 새로운 로그를 추가하는 기능을 통합하는 방법이 있습니다. 클라이언트에서는 새로운 로그를 추가할 때 /get_logs 엔드포인트에 POST 요청을 보내면 됩니다. 이렇게 하면 서버는 POST 요청을 받아 새로운 로그를 데이터베이스에 추가하고, 이후에는 업데이트된 로그 데이터를 클라이언트에게 다시 제공할 수 있습니다.

아래는 get_logs 엔드포인트를 수정하여 새로운 로그를 추가하는 기능을 통합하는 예시 코드

# 데이터베이스에서 로그 정보 가져오기 및 새로운 로그 추가
@app.route('/get_logs', methods=['GET', 'POST'])
def get_logs():
    if request.method == 'GET':
        conn = get_db_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT date, occurrence_time, incident FROM cctvlog")
        logs = cursor.fetchall()
        conn.close()
        return render_template('index_frame.html', logs=logs)
    elif request.method == 'POST':
        date = request.form['date']
        occurrence_time = request.form['occurrence_time']
        incident = request.form['incident']
X      add_log(date, occurrence_time, incident)  # 새로운 로그 추가
        return redirect(url_for('get_logs'))  # 다시 로그 데이터를 가져와서 페이지 업데이트

>GET 요청:

클라이언트가 GET 요청을 보내면, 서버는 데이터베이스에서 로그 정보를 가져와서 화면에 표시합니다.
이를 위해 SQLite 데이터베이스에서 'cctvlog' 테이블로부터 날짜(date), 발생 시간(occurrence_time), 사건(incident) 정보를 가져옵니다.
가져온 정보는 render_template 함수를 사용하여 'index_frame.html' 템플릿에 전달됩니다.

>POST 요청:

클라이언트가 POST 요청을 보내면, 새로운 로그 정보를 받아와서 데이터베이스에 추가합니다.
요청에서 받아온 날짜(date), 발생 시간(occurrence_time), 사건(incident) 정보를 사용하여 add_log 함수를 호출하여 데이터베이스에 새로운 로그를 추가합니다.
추가한 후에는 redirect 함수를 사용하여 다시 GET 요청을 보내서 로그 데이터를 가져와서 페이지를 업데이트합니다.
이렇게 하면 클라이언트가 페이지를 새로 고치지 않고도 새로운 로그를 추가할 수 있으며, 추가된 로그는 즉시 화면에 표시됩니다.

>>> 그런데 add_log를 찾을수 없다고 한다. 이걸 어떻게 해결해야할까?

add_log 함수를 찾을 수 없는 오류가 발생한다면, 아마도 add_log 함수가 정의되지 않았거나 잘못된 곳에 정의되어 있을 가능성이 있습니다.

이 함수가 app.py 파일에 정의되어 있어야 합니다. 이 함수가 정의되어 있는지 확인하고, 정의된 위치가 get_logs 함수가 있는 코드 블록 내에 있어야 합니다.

예를 들어, add_log 함수가 다음과 같이 정의되어 있어야 합니다:

---- 5교시

코드를 살펴본 결과, /logs 라우트와 logs() 함수에서 POST 요청에 대한 처리와 GET 요청에 대한 처리가 동일합니다. 이로 인해 같은 데이터를 두 번 가져오게 되어 로그가 두 번 출력될 수 있습니다.

POST 요청의 경우, 데이터를 새로 추가한 후에 다시 모든 로그를 가져오고 이를 템플릿으로 렌더링합니다. 하지만 이러한 처리는 GET 요청에서도 동일하게 이루어지고 있습니다. 그러므로 로그를 중복으로 가져오는 문제가 발생합니다.

해결책으로는 logs() 함수에서 GET 요청에 대한 처리와 POST 요청에 대한 처리를 분리하여, POST 요청에서는 데이터를 추가한 후 리다이렉트하고, GET 요청에서는 로그를 가져오고 템플릿을 렌더링하는 방식으로 수정하는 것입니다. 이를 위해 먼저 GET 요청에서 데이터를 가져오고 템플릿을 렌더링하는 부분을 따로 함수로 분리하겠습니다.

... 코딩)
위 코드에서는 GET 요청에서 로그 데이터를 가져오는 부분을 get_logs() 함수를 호출하여 따로 처리하고, POST 요청에서는 데이터를 추가한 후 다시 /logs 페이지로 리다이렉트하도록 수정하였습니다. 이렇게 하면 중복된 로그가 출력되는 문제를 해결할 수 있습니다.

그러나 해결되지 않았습니다.

>>> 해결했다.
getElementById('body')는 문서 내에서 id가 'body'로 지정된 요소를 찾아 반환합니다. 따라서 해당 코드는 'body'라는 id를 가진 요소를 찾아 변수 logTableBody에 할당하는 것입니다.

이러한 코드를 사용하려면 HTML 코드에서 아래와 같이 특정 요소에 id를 부여해야 합니다.
 body 태그에 id를 'body'로 지정하면 JavaScript에서 해당 요소를 찾아서 사용할 수 있습니다. 이후 JavaScript 코드에서 logTableBody를 사용하여 해당 요소에 접근할 수 있습니다.









































