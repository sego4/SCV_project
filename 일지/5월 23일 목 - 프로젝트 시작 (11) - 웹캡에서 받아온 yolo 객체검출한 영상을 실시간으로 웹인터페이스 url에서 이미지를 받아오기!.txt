5ì›” 23ì¼ ëª© â†’ â€» â–¶ â—ˆ âˆ´ ğŸ«¡ â¤

-----------------------------------------------------------------
Predict.pyë¥¼ í†µí•´ ì´ë¯¸ì§€ë¥¼ (ê°ì²´)ê²€ì¶œí•˜ê³  ê·¸ ê²€ì¶œí•œ ì´ë¯¸ì§€ê°€ cctv_frame.htmlì—ì„œ ë„ìš°ê³  ì‹¶ìŠµë‹ˆë‹¤!
ê·¸ëŸ¬ë ¤ë©´ app.pyì—ì„œ ì„í¬íŠ¸ë‚˜ ì½”ë”©ì„ í†µí•´ì„œ ë¼ìš°íŠ¸ë¥¼ í•´ì£¼ê³  (ë Œë”ë§ì€ ë¬´ìŠ¨ ê´€ë ¨ì´?)
Javascript ì½”ë“œë¥¼ í™”ë©´ì„ ë„ìš¸ .html íŒŒì¼ì— ì½”ë”©ì„ í•´ì¤˜ì•¼í• ê²ƒ ê°™ìŠµë‹ˆë‹¤. ë§ìŠµë‹ˆê¹Œ?


ë„¤, ë§ìŠµë‹ˆë‹¤. ì´ë¯¸ì§€ë¥¼ ê°ì²´ ê²€ì¶œí•˜ê³  ê·¸ ì´ë¯¸ì§€ë¥¼ cctv_frame.htmlì— ë„ìš°ê¸° ìœ„í•´ì„œëŠ” ë‹¤ìŒê³¼ ê°™ì€ ë‹¨ê³„ë¥¼ ë”°ë¼ì•¼ í•©ë‹ˆë‹¤.

1. ê°ì²´ ê²€ì¶œ ì½”ë“œ (predict.py) ì¤€ë¹„:
- predict.py íŒŒì¼ì—ì„œ ì´ë¯¸ì§€ë¥¼ ì…ë ¥ë°›ì•„ ê°ì²´ë¥¼ ê²€ì¶œí•˜ê³ , ê²°ê³¼ ì´ë¯¸ì§€ë¥¼ ì €ì¥í•˜ê±°ë‚˜ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜ë¥¼ ì‘ì„±í•©ë‹ˆë‹¤.

# predict.py
import cv2

def detect_objects(input_image_path, output_image_path):
    # ê°ì²´ ê²€ì¶œ ë¡œì§ (ì˜ˆ: OpenCVë¥¼ ì‚¬ìš©í•œ ê°ì²´ ê²€ì¶œ)
    image = cv2.imread(input_image_path)
    # ê°ì²´ ê²€ì¶œì„ ìˆ˜í–‰í•˜ê³  ê²°ê³¼ ì´ë¯¸ì§€ë¥¼ ì €ì¥
    cv2.imwrite(output_image_path, image)
    return output_image_path

2. Flask ì• í”Œë¦¬ì¼€ì´ì…˜ (app.py) ì„¤ì •:
- Flaskë¥¼ ì‚¬ìš©í•˜ì—¬ ì›¹ ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì„¤ì •í•˜ê³ , ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•˜ê³  ê°ì²´ë¥¼ ê²€ì¶œí•œ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” ë¼ìš°íŠ¸ë¥¼ ë§Œë“­ë‹ˆë‹¤.

# app.py
from flask import Flask, request, render_template, send_file
import os
from predict import detect_objects

app = Flask(__name__)

UPLOAD_FOLDER = 'uploads/'
RESULT_FOLDER = 'results/'
app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['RESULT_FOLDER'] = RESULT_FOLDER

@app.route('/')
def index():
    return render_template('cctv_frame.html')

@app.route('/upload', methods=['POST'])
def upload_file():
    if 'file' not in request.files:
        return 'No file part'
    file = request.files['file']
    if file.filename == '':
        return 'No selected file'
    if file:
        input_image_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
        file.save(input_image_path)
        
        output_image_path = os.path.join(app.config['RESULT_FOLDER'], 'result_' + file.filename)
        detect_objects(input_image_path, output_image_path)
        
        return render_template('cctv_frame.html', result_image=output_image_path)

@app.route('/results/<filename>')
def send_result_file(filename):
    return send_file(os.path.join(app.config['RESULT_FOLDER'], filename))

if __name__ == '__main__':
    app.run(debug=True)

3. HTML íŒŒì¼ (cctv_frame.html) ì¤€ë¹„:
- HTML íŒŒì¼ì—ì„œ ì—…ë¡œë“œ í¼ê³¼ ê²°ê³¼ ì´ë¯¸ì§€ë¥¼ ë³´ì—¬ì¤„ ì½”ë“œë¥¼ ì‘ì„±í•©ë‹ˆë‹¤. JavaScriptë¥¼ ì‚¬ìš©í•˜ì—¬ í¼ ì œì¶œ ì‹œ ì´ë¯¸ì§€ë¥¼ ì„œë²„ë¡œ ì—…ë¡œë“œí•˜ê³ , ê²°ê³¼ ì´ë¯¸ì§€ë¥¼ í™”ë©´ì— ë„ì›ë‹ˆë‹¤.

<!-- cctv_frame.html -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CCTV Frame</title>
</head>
<body>
    <h1>Upload an Image for Object Detection</h1>
    <form id="uploadForm" action="/upload" method="post" enctype="multipart/form-data">
        <input type="file" name="file" accept="image/*">
        <button type="submit">Upload</button>
    </form>

    <div id="result">
        {% if result_image %}
            <h2>Detected Objects:</h2>
            <img src="{{ url_for('send_result_file', filename=result_image.split('/')[-1]) }}" alt="Result Image">
        {% endif %}
    </div>

    <script>
        document.getElementById('uploadForm').addEventListener('submit', function(event) {
            event.preventDefault();

            var formData = new FormData(this);

            fetch('/upload', {
                method: 'POST',
                body: formData
            }).then(response => response.text())
            .then(html => {
                document.body.innerHTML = html;
            });
        });
    </script>
</body>
</html>

ì¼ë‹¨ì€ ê¸°ë³¸ì ì¸ ë‚´ìš©ì´ê³  ì—¬ê¸°ì„œ ì„¸ë¶€ ë‚´ìš©ì€ ë‚´ê°€ ìˆ˜ì •í•´ì•¼í•œë‹¤.

ìœ„ ì½”ë“œë“¤ì€ ë‹¤ìŒê³¼ ê°™ì€ ìˆœì„œë¡œ ì‘ë™!

1. ì‚¬ìš©ìê°€ ì›¹ í˜ì´ì§€ ("cctv_frame.html")ì—ì„œ ì´ë¯¸ì§€ë¥¼ ì—…ë¡œë“œí•©ë‹ˆë‹¤.

2. ì´ë¯¸ì§€ëŠ” Flask ì„œë²„ë¡œ ì „ì†¡ë©ë‹ˆë‹¤. ('/upload' ì—”ë“œí¬ì¸íŠ¸ë¡œ ëë§ºìŒ í•´ì•¼í•œë‹¤).

3. ì„œë²„ëŠ” ì´ë¯¸ì§€ë¥¼ ì €ì¥í•˜ê³ , 'predict.py'ì—ì„œ ê°ì²´ ê²€ì¶œì„ ìˆ˜í–‰í•˜ì—¬ ê²°ê³¼ ì´ë¯¸ì§€ë¥¼ ì €ì¥í•©ë‹ˆë‹¤.

4. ê²°ê³¼ ì´ë¯¸ì§€ëŠ” "cctv_frame.html"ì—ì„œ ë³´ì—¬ì§‘ë‹ˆë‹¤. - ì¶œë ¥ê³¼ êµ¬í˜„ì„ ì˜ë¯¸!

5. JavaScriptë¥¼ ì‚¬ìš©í•˜ì—¬ í¼ì„ ì œì¶œí•˜ê³ , ì„œë²„ì˜ ì‘ë‹µì„ ë°›ì•„ í˜ì—ì§€ë¥¼ ë™ì ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.

> ì´ë ‡ê²Œ í•˜ë©´ ê°ì²´ ê²€ì¶œëœ ì´ë¯¸ì§€ë¥¼ ì›¹í˜ì´ì§€ì— ë„ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.




>>> ---- 3êµì‹œ

ëª¨ë¸ ê²½ë¡œë¥¼ C:\Users\602-13\kë¡œ ì„¤ì •í•˜ë ¤ë©´ YOLO í´ë˜ìŠ¤ ì´ˆê¸°í™” ì‹œ ê²½ë¡œë¥¼ í•´ë‹¹ ê²½ë¡œë¡œ ë³€ê²½í•˜ë©´ ë©ë‹ˆë‹¤. ì´ ë³€ê²½ ì‚¬í•­ì„ ë°˜ì˜í•œ predict.py ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:

import cv2
from ultralytics import YOLO
import datetime
import os

class Predict:
    def __init__(self):
        self.size = (960, 540)
        # ëª¨ë¸ ê²½ë¡œ ìˆ˜ì •
        self.model = YOLO('C:/Users/602-13/k/weights/best.pt')
        self.labels = []
        with open("label.txt", "r", encoding="utf-8") as f:
            self.labels = [line.strip() for line in f.readlines()]

    def detect_objects(self, video_path):
        cap = cv2.VideoCapture(video_path)
        fps = int(cap.get(cv2.CAP_PROP_FPS))
        date = datetime.date.today()
        directory = "static/results"
        if not os.path.exists(directory):
            os.makedirs(directory)

        filename = f"{date.strftime('%Y-%m-%d')}_yolo.avi"
        filepath = os.path.join(directory, filename)
        fourcc = cv2.VideoWriter_fourcc(*'XVID')
        out = cv2.VideoWriter(filepath, fourcc, fps, self.size)

        while cap.isOpened():
            ret, frame = cap.read()
            if not ret:
                break
            resized_frame = cv2.resize(frame, self.size)
            results = self.model(resized_frame)
            plots = results[0].plot()
            bgr_plots = cv2.cvtColor(plots, cv2.COLOR_RGB2BGR)
            out.write(bgr_plots)

        cap.release()
        out.release()
        return filepath

# Instantiate the class to be used in app.py
predict_instance = Predict()

 ì´ì œ ì´ predict.pyë¥¼ ì‚¬ìš©í•˜ëŠ” app.py íŒŒì¼ì„ ì„¤ì •í•´ ë³´ê² ìŠµë‹ˆë‹¤. 
Flask ì• í”Œë¦¬ì¼€ì´ì…˜ì´ predict.pyì˜ ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ì—¬ ê°ì²´ ê²€ì¶œì„ ìˆ˜í–‰í•˜ê³  ê²°ê³¼ë¥¼ HTML í˜ì´ì§€ì— í‘œì‹œí•˜ë„ë¡ í•˜ê² ìŠµë‹ˆë‹¤.

app.py ì„¤ì •
app.pyëŠ” Flaskë¥¼ ì‚¬ìš©í•˜ì—¬ ì›¹ ì„œë²„ë¥¼ ì„¤ì •í•˜ê³ , /detect ê²½ë¡œì—ì„œ ê°ì²´ ê²€ì¶œì„ ìˆ˜í–‰í•˜ì—¬ ê²°ê³¼ë¥¼ ë°˜í™˜í•˜ëŠ” ì—­í• ì„ í•©ë‹ˆë‹¤.

...
cctv_frame.html ì„¤ì •
ê²°ê³¼ ë™ì˜ìƒì„ í‘œì‹œí•˜ëŠ” HTML íŒŒì¼ì„ ì„¤ì •í•©ë‹ˆë‹¤.

...

ì´ì œ 'app.py'ì™€ 'cctv_frame.html' íŒŒì¼ì´ 'predict.py'ì—ì„œ ê°ì²´ ê²€ì¶œì„ ìˆ˜í–‰í•œ ê²°ê³¼ ë™ì˜ìƒì„ í‘œì‹œí•  ìˆ˜ ìˆë„ë¡ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤. Flask ì• í”Œë¦¬ì¼€ì´ì…˜ì„ ì‹¤í–‰í•˜ê³  ë¸Œë¼ìš°ì €ì—ì„œ í…ŒìŠ¤íŠ¸í•˜ì—¬ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ì‹­ì‹œì˜¤.


---- 4êµì‹œ

<app.pyë¥¼ ë‚´ê°€ ê°–ê³  ìˆëŠ” íŒŒì¼ì— ë…¹ì•„ë“¤ë„ë¡ í•´ì£¼ì!>
 ì£¼ì–´ì§„ app.py ì½”ë“œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ê°ì²´ ê²€ì¶œ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ëŠ” ë°©ë²•ì„ ì„¤ëª…í•˜ê² ìŠµë‹ˆë‹¤. ì´ ê³¼ì •ì—ì„œëŠ” ì‚¬ìš©ìê°€ ì—…ë¡œë“œí•œ ë™ì˜ìƒ íŒŒì¼ì„ predict.pyì˜ Predict í´ë˜ìŠ¤ë¥¼ í†µí•´ ì²˜ë¦¬í•˜ê³ , ê·¸ ê²°ê³¼ë¥¼ ë³´ì—¬ì£¼ëŠ” ë¼ìš°íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

app.py ì—…ë°ì´íŠ¸
1. í•„ìš”í•œ ëª¨ë“ˆ ê°€ì ¸ì˜¤ê¸°: Predict í´ë˜ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ê°€ì ¸ì˜¤ê¸° ìœ„í•´ predict.pyë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
2. íŒŒì¼ ì—…ë¡œë“œ ë¼ìš°íŠ¸ ì¶”ê°€: ì‚¬ìš©ìê°€ ë™ì˜ìƒì„ ì—…ë¡œë“œí•˜ê³ , ê²€ì¶œ ê²°ê³¼ë¥¼ ë³´ì—¬ì£¼ëŠ” ë¼ìš°íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
3. ê²°ê³¼ í˜ì´ì§€ ë¼ìš°íŠ¸ ì¶”ê°€: ê²€ì¶œ ê²°ê³¼ ë™ì˜ìƒì„ ë³´ì—¬ì£¼ëŠ” ë¼ìš°íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
ì´ ë³€ê²½ ì‚¬í•­ì„ ë°˜ì˜í•œ app.py ì½”ë“œëŠ” ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤:


Ultralytics YOLO ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì„¤ì¹˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•˜ë ¤ë©´ pip install ultralytics ëª…ë ¹ì„ ì‚¬ìš©í•˜ì—¬ ì„¤ì¹˜í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.


í•´ë‹¹ ì˜¤ë¥˜ëŠ” PyTorchê°€ í•„ìš”í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬ íŒŒì¼ì„ ì°¾ì§€ ëª»í•´ì„œ ë°œìƒí•œ ê²ƒì…ë‹ˆë‹¤. Windows í™˜ê²½ì—ì„œ PyTorch ë° ê·¸ ì˜ì¡´ì„±ì„ ì œëŒ€ë¡œ ì„¤ì¹˜í–ˆëŠ”ì§€ í™•ì¸í•´ì•¼ í•©ë‹ˆë‹¤.

í•´ê²° ë°©ë²•
CUDA ì„¤ì¹˜ í™•ì¸ ë° í™˜ê²½ ë³€ìˆ˜ ì„¤ì •:

PyTorchëŠ” GPU ì§€ì›ì„ ìœ„í•´ CUDAë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤. ì‹œìŠ¤í…œì— ë§ëŠ” CUDA Toolkitì„ ì„¤ì¹˜í•˜ê³  í™˜ê²½ ë³€ìˆ˜ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì„¤ì •í–ˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
1. CUDA ì„¤ì¹˜ í›„, PATH í™˜ê²½ ë³€ìˆ˜ì— CUDAì˜ bin ë””ë ‰í† ë¦¬ë¥¼ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.2\binê³¼ ê°™ì€ ê²½ë¡œë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.

2. PyTorch ì¬ì„¤ì¹˜:

PyTorchì™€ ê´€ë ¨ëœ ë¬¸ì œê°€ ìˆì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ PyTorchë¥¼ ì¬ì„¤ì¹˜í•´ë´…ë‹ˆë‹¤. ì•„ë˜ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„¤ì¹˜í•©ë‹ˆë‹¤. pipì„ ì‚¬ìš©í•˜ê³  ìˆìœ¼ë©°, torch ë° torchvisionì„ í•¨ê»˜ ì„¤ì¹˜í•©ë‹ˆë‹¤.

3. ëª¨ë“  ì˜ì¡´ì„± ì—…ë°ì´íŠ¸:

requirements.txt íŒŒì¼ì— ìˆëŠ” ëª¨ë“  ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ìµœì‹  ë²„ì „ìœ¼ë¡œ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤. ì´ë¥¼ ìœ„í•´ ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
>> pip install -r requirements.txt --upgrade

----

í•´ê²°í–ˆë‹¤.

ì˜¤ë¥˜ ë©”ì‹œì§€ì—ì„œ dill ëª¨ë“ˆì´ í•„ìš”í•˜ì§€ë§Œ ì°¾ì„ ìˆ˜ ì—†ë‹¤ëŠ” ë‚´ìš©ì´ ë‚˜ì˜µë‹ˆë‹¤. ì´ ë¬¸ì œëŠ” í™˜ê²½ ì„¤ì •ì´ë‚˜ ê²½ë¡œ ë¬¸ì œë¡œ ì¸í•´ ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì•„ë˜ëŠ” ì´ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ ë‹¨ê³„ì…ë‹ˆë‹¤:


1. dill ì¬ì„¤ì¹˜:
ë•Œë•Œë¡œ íŒ¨í‚¤ì§€ë¥¼ ì¬ì„¤ì¹˜í•˜ë©´ ë¬¸ì œê°€ í•´ê²°ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. dillì„ ì œê±°í•œ í›„ ë‹¤ì‹œ ì„¤ì¹˜í•´ ë³´ì„¸ìš”:
- pip uninstall dill

2. ì˜¬ë°”ë¥¸ í™˜ê²½ í™•ì¸:
dillì´ ì„¤ì¹˜ëœ ë™ì¼í•œ Python í™˜ê²½ì—ì„œ Flask ì•±ì„ ì‹¤í–‰í•˜ê³  ìˆëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”. í˜„ì¬ í™˜ê²½ì—ì„œ ì„¤ì¹˜ëœ íŒ¨í‚¤ì§€ ëª©ë¡ì„ í™•ì¸í•˜ë ¤ë©´ ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”:
- pip list 
ë¥¼ í†µí•´ì„œ ì‚­ì œë˜ì—ˆëŠ”ì§€ í™•ì¸

3. dill ì„¤ì¹˜ í›„ í™•ì¸! 

4. Python ì…¸ì—ì„œ ê°€ì ¸ì˜¤ê¸° í…ŒìŠ¤íŠ¸:
ë™ì¼í•œ í™˜ê²½ì—ì„œ Python ì…¸ì„ ì—´ê³  dillì„ ê°€ì ¸ì˜¬ ìˆ˜ ìˆëŠ”ì§€ í…ŒìŠ¤íŠ¸í•˜ì„¸ìš”:
- import dill

5. ê°€ìƒ í™˜ê²½ ì‚¬ìš©:
ê°€ìƒ í™˜ê²½ì„ ì‚¬ìš©í•˜ì—¬ ì˜ì¡´ì„±ì„ ê²©ë¦¬í•˜ëŠ” ê²ƒì´ ì¢‹ìŠµë‹ˆë‹¤. ë‹¤ìŒ ëª…ë ¹ì–´ë¡œ ê°€ìƒ í™˜ê²½ì„ ì„¤ì •í•˜ì„¸ìš”:

python -m venv myenv

- `myenv\Scripts\activate`
- pip install flask dill torch ultralytics






































